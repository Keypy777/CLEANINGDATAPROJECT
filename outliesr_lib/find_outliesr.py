# -*- coding: utf-8 -*-
import pandas as pd
import numpy as np



"""
1. Аргументы функции
    data — DataFrame (таблица данных), в которой ищутся выбросы.
    feature — название столбца (признака), по которому проводится анализ.
    log_scale — булевый параметр (по умолчанию False). Если True, признак логарифмируется.
2. Логарифмирование признака (если требуется)
    Если log_scale=True, к выбранному признаку применяется логарифмирование (np.log(x+1)). Это часто делают для признаков с сильной асимметрией (например, зарплаты, количество просмотров).
    Если log_scale=False, признак используется в исходном виде.
3. Вычисление среднего и стандартного отклонения
    mu — среднее значение признака (или его логарифма).
    sigma — стандартное отклонение признака (или его логарифма).
4. Определение границ для выбросов
    Нижняя граница: среднее минус три стандартных отклонения.
    Верхняя граница: среднее плюс три стандартных отклонения.
    Это классический критерий "трёх сигм": всё, что выходит за эти границы, считается выбросом.
5. Поиск выбросов и очищенных данных
    outliers — строки, где значение признака меньше нижней или больше верхней границы (выбросы).
    cleaned — строки, где значение признака находится в пределах границ (очищенные данные).
6. Возврат результата
    Функция возвращает два DataFrame:
    Первый — только выбросы.
    Второй — очищенные от выбросов данные.
"""


def outliers_z_score(data, feature, log_scale=False):
    if log_scale:
        x = np.log(data[feature]+1)
    else:
        x = data[feature]
    mu = x.mean()
    sigma = x.std()
    lower_bound = mu - 3 * sigma
    upper_bound = mu + 3 * sigma
    outliers = data[(x < lower_bound) | (x > upper_bound)]
    cleaned = data[(x >= lower_bound) & (x <= upper_bound)]
    return outliers, cleaned

def outliers_iqr_mod(data, feature, left=1.5, right=1.5, log_scale=False):
    """
    
    1. Аргументы функции
        * data — DataFrame (таблица данных) или путь к CSV-файлу, в котором ищутся выбросы.
        * feature — название столбца (признака), по которому проводится анализ.
        * left — множитель для нижней границы (по умолчанию 1.5).
        * right — множитель для верхней границы (по умолчанию 1.5).
        * log_scale — булевый параметр (по умолчанию False). Если True, признак логарифмируется.
    2. Импорт библиотек
           * Импортируются необходимые библиотеки для работы с данными и вычислениями.
    3. Загрузка данных (если нужно)
        * Если в качестве data передана строка (путь к файлу), функция загружает данные из CSV-файла в DataFrame.
    4. Логарифмирование признака (если требуется)
        * Если log_scale=True, к выбранному признаку применяется логарифмирование (np.log(x+1)). Это часто делают для признаков с сильной асимметрией (например, зарплаты, количество просмотров).
        * Если log_scale=False, признак используется в исходном виде.
    5. Вычисление квартилей и межквартильного размаха
        * q1 — первый квартиль (25-й процентиль) признака.
        * q3 — третий квартиль (75-й процентиль) признака.
        * iqr — межквартильный размах (разница между q3 и q1).
    6. Определение границ для выбросов
        * Нижняя граница: q1 минус left * iqr.
        * Верхняя граница: q3 плюс right * iqr.
        * Эти границы определяют диапазон, в котором значения признака считаются нормальными
        * Всё, что выходит за эти границы, считается выбросом.
    7. Поиск выбросов и очищенных данных
        * outliers — строки, где значение признака меньше нижней или больше верхней границы (выбросы).
        * cleaned — строки, где значение признака находится в пределах границ (очищенные данные).
    8. Возврат результата
        * Функция возвращает два DataFrame:
            * Первый — только выбросы.
            * Второй — очищенные от выбросов данные.
    """
    import pandas as pd
    import numpy as np
    # Если data — строка, читаем csv
    if isinstance(data, str):
        data = pd.read_csv(data)
    if log_scale:
        x = np.log(data[feature] + 1)
    else:
        x = data[feature]
    q1 = x.quantile(0.25)
    q3 = x.quantile(0.75)
    iqr = q3 - q1
    lower_bound = q1 - left * iqr
    upper_bound = q3 + right * iqr
    outliers = data[(x < lower_bound) | (x > upper_bound)]
    cleaned = data[(x >= lower_bound) & (x <= upper_bound)]
    return outliers, cleaned